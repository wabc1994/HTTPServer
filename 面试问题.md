# 面试被问过的问题

* 介绍一下这个项目(几乎是必问的)
* 定时器是怎么实现的？还有什么实现方式？
* 实现一个无锁队列(用原子操作)
* eventfd是什么？有什么好处？
* 双缓冲区异步日志是什么？为什么要这样做？对这个日志系统有没有进行压力测试？
* 什么是优雅关闭连接？(就是read()到0，要透明的传递这个行为而不是直接暴力close())
* epoll的边沿触发和水平触发有什么区别？(epoll的源码并不长，从源码的角度回答比较好)
* epoll为什么高效，相比select和poll
* HTTP报文都有哪些字段？
* 假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)
* 有没有实现内存池？
* 一个请求到来具体的处理过程是怎样的？
>首先基于Reactor模型， socket.fd**(先封装为HttpData，封装成为channel(ioloop,fd))**已经被放到ioLoop，通过多路复用监听到fd已经可以用，并开始调用
对应的事件处理函数(handleRead()、hanleWrite()和handleCon())，这些函数是在channel 当中进行注册的，实际调用的是HttpData当中定义的

最底层：对于一个套接口上的输入操作，第一步一般是等待数据到达网络，当分组到达时，它被拷贝到内核中的某个缓冲区，第二步是将数据从内核缓冲区拷贝到应用缓冲区。
* 线程的唤醒还有哪些方式？
* 怎么检查内存泄漏的？
* 用到了哪些智能指针和RAII机制，几种锁的区别是什么

一种是引用计数指针 shared_ptr和weak_ptr

shared_ptr中所实现的本质是引用计数(reference),当引用计数变成0的时候，自动调用析构函数释放对象的内存

RAII [1]Resource Acquisition Is Initialization）,也称为“资源获取就是初始化”，是C++语言的一种管理资源、避免泄漏的惯用法。C++标准保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。简单的说，RAII 的做法是使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。

- 在系统中，资源是有限的，一旦用完必须归还给系统，否则可能会造成资源耗尽或其他问题。例如，动态分配的内存如果用完不释放会造成内存泄漏。
这里说的资源不仅仅是指内存，还包括其他，例如文件描述符、网络连接、数据库连接、互斥锁等。



* 任务队列是怎么实现的，除了加锁还有什么方式？
条件变量
* 如何解决死锁？
* 怎么进行压测的？
* 为什么要用非阻塞io？
* 为什么要做这个项目？
* Reactor模式是什么？

# I/O模型
我们知道有五种常用的I/O模型， 并且所有的系统I/O操作分为两个阶段：等待内核数据准备就绪和真实读写阶段。
举例来说,读函数，分为等待系统可读和真正的读，同理，写函数分为等待网卡可以写和真正的写。

**这两个阶段有什么区别?**

>所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。

需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在”干活”，而且这个过程非常快，属于memory copy，


[Java NIO浅析 - 美团技术团队](https://tech.meituan.com/2016/11/04/nio.html)

NIO事件分为 可读，可写，处理连接

# Reactor模式
- 事件驱动模型
- 避免多线程
- 单线程处理多任务
- 非阻塞


1. 反应器模式：反应器设计模型是一种为处
理并发服务请求，并将请求提交到一个或多个服务处理程序的事件设计模型。当客户端的请求抵达后，服务处理程序使用多路分配策略，由
一个非阻塞的线程来接收所有的请求，后派发这些请求至相关的工作线程进行处理。

**Reactor模式优点**

1. 响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；
2. 编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；
3. 可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；
4. 可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性


# 如何理解Reactor + 非阻塞I/0 + I/O复用

非阻塞I/O是指I/0操作的第二部分，数据读取和写入(真正的I/O操作)， I/O复用是指等待数据准备好的阶段

select()等系统调用是阻塞的

还是从五种模型说起，第一种是阻塞I/0 ,read()和write()阻塞在数据准备阶段和数据操作两个阶段，
- 单纯的非阻塞I/O，read()和write()要一直自己进行询问**(自己询问)**，是否准备好数据，
- I/O复用的本质，就是select,epoll,poll()**(别人帮我询问)**作用于数据准备阶段，而read()和write()作用第二阶段，一开始如果没准备好读写，那么read()和write立即返回，可以去做别的事情，不用浪费CPU,然后就等待select,epoll等返回准备就绪描述符就可以了

# 为何有了I/O复用还还用非阻塞I/O ?

- 使用 epoll当中的ET模型必须要使用非阻塞的方式，**可以用 while 来循环 accept()。**

[IO 多路复用要搭配非阻塞 IO? ](https://www.zhihu.com/question/37271342)

[在使用Multiplexed I/O的情况下，还有必要使用Non Blocking I/O ？](https://www.zhihu.com/question/33072351/answer/55925265)

# 智能指针的问题

**究竟什么时候使用share_ptr什么时候使用weak_ptr？**
-  std::weak_ptr<TimerNode> timer_;
-  std::vector<std::shared_ptr<EventLoopThread>> threads_;
-  std::unique_ptr<EventLoopThreadPool> eventLoopThreadPool_;

绝大部分场合都该用unique_ptr。使用weak_ptr主要解决两个问题
1. 空悬指针
2. 循环引用


#