Log的设计仿照了muduo库的设计,但我写的没那么复杂
https://github.com/chenshuo/muduo

与Log相关的类包括FileUtil、LogFile、AsyncLogging、LogStream、Logging。
其中前4个类每一个类都含有一个append函数，Log的设计也是主要围绕这个append函数展开的。

FileUtil是最底层的文件类，封装了Log文件的打开、写入并在类析构的时候关闭文件，底层使用了标准IO，该append函数直接向文件写。
LogFile进一步封装了FileUtil，并设置了一个循环次数，没过这么多次就flush一次。
AsyncLogging是核心，它负责启动一个log线程，专门用来将log写入LogFile，应用了“双缓冲技术”，其实有4个以上的缓冲区，但思想是一样的。（负责线程类）
AsyncLogging负责(定时到或被填满时)将缓冲区中的数据写入LogFile中。
LogStream主要用来格式化输出，，同时也有自己的一块缓冲重载了<<运算符区，这里缓冲区的存在是为了缓存一行，把多个<<的结果连成一块。（格式化输出，并且重载<< 这个运算符）
Logging是对外接口，Logging类内涵一个LogStream对象，主要是为了每次打log的时候在log之前和之后加上固定的格式化的信息，比如打log的行、
文件名等信息。

减少线程之间的竞争， 采用

1. 日志消息格式：
2. 日志文件的命名格式：

1. 日志级别: DEBUG, INFO, WARN, ERROR, FATAL，

[可以参考这篇论文](https://github.com/baozh/zlog/blob/master/readme.md)

日志输出过快、来不及消费，怎么办？
直接丢弃多余的日志，启一个协程等待一个可用的Buffer，当Buffer可用后 写入 丢弃日志的开始时间 和 结束时间。





文件名字的格式化和文件

日期  	    时间.微秒   	pid  日志级别  源文件名：行号：函数名 -   正文
20160609 23:31:21.770367   28599 ERROR    demo.go:33:main.main - Hello  正文就是日志的输入文件件



日期-时间.basename.主机名.pid.log
20160609-22171.file_demo.bzh-HP-Pavilion-m4-Notebook-PC.27204.log
注：basename是可执行文件的名字

* __FILE__:返回所在文件名
 * __LINE__:返回所在行数
 * __func__:返回所在函数名

